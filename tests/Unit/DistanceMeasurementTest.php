<?php

namespace Tests\Unit;

use App\Models\Dtos\AffiliateGeoPositionDto;
use App\Services\DistanceFormulas\SurfaceDistanceFormulaInterface;
use PHPUnit\Framework\TestCase;
use Tests\CreatesApplication;

class DistanceMeasurementTest extends TestCase
{
    use CreatesApplication;

    private SurfaceDistanceFormulaInterface $calculator;

    private AffiliateGeoPositionDto $centre;

    private AffiliateGeoPositionDto $first;

    private array $samples = array();

    /**
     * Collection of positions with expected measurement. This is to validate that measured distances are as expected
     * @var array
     */
    private array $measuredSamples = array();

    protected function setUp(): void
    {
        parent::setUp(); // TODO: Change the autogenerated stub
        $application = $this->createApplication();
        $this->calculator = $application->make(SurfaceDistanceFormulaInterface::class);
        $this->centre = new AffiliateGeoPositionDto(53.3340285, -6.2535495);
        $this->first = new AffiliateGeoPositionDto(52.986375, -6.043701);
        $this->fillSamples();
        $this->fillMeasurementSamples();
    }

    private function fillSamples(): void
    {
        $this->samples[] = new AffiliateGeoPositionDto(0,0);
        $this->samples[] = new AffiliateGeoPositionDto(2,3);
        $this->samples[] = new AffiliateGeoPositionDto(35,44.56);
    }

    /**
     * Certain values will produce predictable results, since it should be proportional to radius
     * @return void
     */
    private function fillMeasurementSamples(): void
    {
        $radius = SurfaceDistanceFormulaInterface::RADIUS;
        $total = $radius * M_PI * 2;
        $this->measuredSamples[] = array(new AffiliateGeoPositionDto(0,0), new AffiliateGeoPositionDto(0, 90), $total / 4);
        $this->measuredSamples[] = array(new AffiliateGeoPositionDto(0,0), new AffiliateGeoPositionDto(90, 0), $total / 4);
        $this->measuredSamples[] = array(new AffiliateGeoPositionDto(0,0), new AffiliateGeoPositionDto(45, 0), $total / 8);
        $this->measuredSamples[] = array(new AffiliateGeoPositionDto(0,0), new AffiliateGeoPositionDto(0, 45), $total / 8);
    }

    /**
     * Assumption here is that if formula is even remotely correct, then distance to itself should be 0.0,
     * because it's a dot.
     * @return void
     */
    public function testDistanceToItselfIsNone(): void
    {
        foreach ($this->samples as $sample) {
            $calculatedDistance = $this->calculator->apply($sample, $sample);
            $this->assertEquals(0.0, $calculatedDistance, "Expected to get distance of 0.0 to itself, but got {$calculatedDistance}.");
        }
    }

    /**
     * Traveling A to B and B to A should be the same. Expecting to see at least 3 samples, because 2 points cover one test
     * @return void
     */
    public function testDistancesBackAndForthAreTheSame(): void
    {
        $this->assertCount(3, $this->samples, "Expected to see 3 samples.");

        for ($i = 1; $i < count($this->samples); $i++) {
            $a = $this->samples[$i - 1];
            $b = $this->samples[$i];
            $aToB = $this->calculator->apply($a, $b);
            $bToA = $this->calculator->apply($b, $a);
            $this->assertEquals($aToB, $bToA, "Expected to see the same distance, but got this: {$aToB}, {$bToA}.");
        }
    }

    /**
     * There is a potential 0.5% difference between calculated and actual values potentially (if formulas are changed
     * that is).Distance to first point is pre-calculated in advance, so this is just to check if results
     * still make sense.
     * @return void
     */
    public function testClosePointOne()
    {
        $expected = 45;
        $delta = $expected * 0.05;
        $calculated = $this->calculator->apply($this->centre, $this->first);
        $this->assertEqualsWithDelta($expected, $calculated, $delta, "Expected ({$expected}) and ({$calculated}) should differ by delta {$delta}");
    }

    /**
     * Few hand-picked examples with precalculated distances. Different formulas produce quite different results
     * sometimes + additional changes to formula interfaces / traits can result in completely broken
     * and incorrect calculations.
     * @return void
     */
    public function testCalculatedDistancesBetweenCentreAndConstantPoint(): void
    {
        $this->assertNotEmpty($this->measuredSamples, 'There should be at least one sample to test.');
        foreach ($this->measuredSamples as $sample) {
            $expected = $sample[2];
            $found = $this->calculator->apply($sample[0], $sample[1]);
            $this->assertEquals($expected, $found, "Expected to get distance of {$expected}, but found {$found}.");
        }
    }
}
